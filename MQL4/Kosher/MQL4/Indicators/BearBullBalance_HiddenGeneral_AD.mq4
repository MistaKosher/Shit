#property copyright "Scriptong"
#property link      "http://advancetools.net"
#property description "Отображение силы быков и медведей без величины обего объема.\nОписание доступно на сайте AdvanceTools.net в разделе \"Тиковые объемы.\""
#property strict

#property indicator_separate_window
#property indicator_buffers 2
#property indicator_color1 clrLime
#property indicator_color2 clrRed

#property indicator_width1 2
#property indicator_width2 2

struct TickStruct                                                                                  // Структура для записи данных об одном тике
{
   datetime time;
   double   bid;
   double   ask;   
};

enum ENUM_TICKSPOINTS
{
    TICKS,                                                                                         // Тики
    POINTS                                                                                         // Пункты
};


// Настроечные параметры индикатора
input ENUM_TICKSPOINTS  i_useTicksAtPrice       = TICKS;                                           // Баланс в тиках или в пунктах
input int               i_indBarsCount          = 50000;                                           // Количество баров для отображения

// Индикаторные буфера
double g_bullBuffer[];
double g_bearBuffer[];
double g_bullPrevalenceBuffer[];
double g_bearPrevalenceBuffer[];


// Прочие глобальные переменные индикатора
bool g_activate,                                                                                   // Признак успешной инициализации индикатора
     g_init;                                                                                       // Переменная для инициализации статических переменных внутри функций в момент проведения..
                                                                                                   // ..повторной инициализации
                                                                                                   
double g_tickSize;

TickStruct        g_ticks[];                                                                       // Массив для хранения тиков, поступивших после начала работы индикатора                    

//+---------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------+
//| Custom indicator initialization function                                                                                                                                                          |
//+---------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------+
int OnInit()
{
   g_activate = false;                                                                             // Индикатор не инициализирован
   g_init = true;
   
   if (!IsTuningParametersCorrect())                                                               // Неверно указанные значения настроечных параметров - причина неудачной инициализации
      return (INIT_FAILED);                                 
           
   if (!BuffersBind())                             
      return (INIT_FAILED);                                 
       
   if (!IsLoadTempTicks())                                                                         // Загрузка данных о тиках, сохраненных за предыдущий период работы индикатора   
      return INIT_FAILED;
           
   g_activate = true;                                                                              // Индикатор успешно инициализирован
   return(INIT_SUCCEEDED);
}
//+---------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------+
//| Проверка корректности настроечных параметров                                                                                                                                                      |
//+---------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------+
bool IsTuningParametersCorrect()
{
   string name = WindowExpertName();

   int period = Period();
   if (period == 0)
   {
      Alert(name, ": фатальная ошибка терминала - период 0 минут. Индикатор отключен.");
      return (false);
   }
   
   g_tickSize = MarketInfo(Symbol(), MODE_TICKSIZE);
   if (g_tickSize == 0)
   {
      Alert(name, ": фатальная ошибка терминала - величина шага одного тика равна нулю. Индикатор отключен.");
      return (false);
   }

   
   return (true);
}
//+---------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------+
//| Связывание буферов индикатора с массивами                                                                                                                                                         |
//+---------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------+
bool BuffersBind()
{
   string name = WindowExpertName();
   IndicatorBuffers(4);

   if (
       !SetIndexBuffer(0, g_bullPrevalenceBuffer)        ||
       !SetIndexBuffer(1, g_bearPrevalenceBuffer)        ||
       !SetIndexBuffer(2, g_bullBuffer)                  ||
       !SetIndexBuffer(3, g_bearBuffer)                 
      )
   {
      Alert(name, ": ошибка связывания массивов с буферами индикатора. Ошибка №", GetLastError());
      return (false);
   }

   for (int i = 0; i < 4; i++)   
   {
      if (i > 1)
         SetIndexStyle(i, DRAW_NONE);
      else      
         SetIndexStyle(i, DRAW_HISTOGRAM);
      SetIndexEmptyValue(i, 0);
   }
      
   SetIndexLabel(0, "Bull Prevalence");
   SetIndexLabel(1, "Bear Prevalence");
   
   return (true);
}
//+---------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------+
//| Чтение данных о тиках, накопленных в течение предыдущей рабочей сессии программы                                                                                                                  |
//+---------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------+
bool IsLoadTempTicks()
{
   // Открытие файла тиковой истории
   int hTicksFile = FileOpen(Symbol() + "temp.tks", FILE_BIN | FILE_READ | FILE_SHARE_READ | FILE_SHARE_WRITE);
   if (hTicksFile < 1)
      return true;
      
   // Распределение памяти для массива g_ticks
   int recSize = (int)(FileSize(hTicksFile) / sizeof(TickStruct));   
   if (ArrayResize(g_ticks, recSize, 1000) < 0)
   {
      Alert(WindowExpertName(), ": не удалось распределить память для подкачки данных из временного файла тиков. Индикатор отключен.");
      FileClose(hTicksFile);
      return false;
   }
   
   // Чтение файла
   int i = 0;
   while (i < recSize)
   {
      if (FileReadStruct(hTicksFile, g_ticks[i]) == 0)
      {
         Alert(WindowExpertName(), ": ошибка чтения данных из временного файла. Индикатор отключен.");
         return false;
      }
      
      i++;
   }

   FileClose(hTicksFile);
   return true;
}
//+---------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------+
//| Custom indicator deinitialization function                                                                                                                                                        |
//+---------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------+
void OnDeinit(const int reason)
{
   if (!IsSavedFile())                                                                             // Если ни один из подключенных индикаторов не сохранил данные, то их сохранит текущий индикатор
      SaveTempTicks();                                                                             // Сохранение данных о тиках, накопленных за текущий период работы индикатора   
}
//+---------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------+
//| Проверка наличия записанных данных другим индикатором                                                                                                                                             |
//+---------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------+
bool IsSavedFile()
{
   // Получение времени поступления последнего записанного тика
   int lastTickIndex = ArraySize(g_ticks) - 1;
   if (lastTickIndex < 0)                                                                          // Ни один тик не был получен. Запись данных не требуется
      return true;

   // Открытие файла тиковой истории
   int hTicksFile = FileOpen(Symbol() + "temp.tks", FILE_BIN | FILE_READ | FILE_SHARE_READ | FILE_SHARE_WRITE);
   if (hTicksFile < 1)
      return false;
   
   // Перемещение к последней записи в файле
   if (!FileSeek(hTicksFile, -sizeof(TickStruct), SEEK_END))
   {
      FileClose(hTicksFile);
      return false;
   }
   
   // Чтение последней записи и закрытие файла
   TickStruct tick;
   uint readBytes = FileReadStruct(hTicksFile, tick);
   FileClose(hTicksFile);
   if (readBytes == 0)
      return false;
  
   // Сравнение даты тика, записанного в файле, и даты последнего поступившего тика
   return tick.time >= g_ticks[lastTickIndex].time;                                                // Дата/время последнего записанного в файле тика больше или равна дате/времени..
                                                                                                   // ..зарегистрированного тика. Значит, файл уже записан, и повторная запись не требуется
}
//+---------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------+
//| Сохранение данных о тиках, накопленных за текущую рабочую сессию программы                                                                                                                        |
//+---------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------+
void SaveTempTicks()
{
   // Создание файла тиковой истории
   int hTicksFile = FileOpen(Symbol() + "temp.tks", FILE_BIN | FILE_READ | FILE_WRITE | FILE_SHARE_READ | FILE_SHARE_WRITE);
   if (hTicksFile < 1)
      return;
   
   // Запись файла
   int total = ArraySize(g_ticks), i = 0;
   while (i < total)
   {
      if (FileWriteStruct(hTicksFile, g_ticks[i]) == 0)
      {
         Print("Ошибка сохранения данных во временный файл...");
         return;
      }
      
      i++;
   }

   FileClose(hTicksFile);
}
//+---------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------+
//| Приведение значений к точности одного тика                                                                                                                                                        |
//+---------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------+
double NP(double value)
{
   if (g_tickSize == 0)
      return (0);
      
   return (MathRound(value / g_tickSize) * g_tickSize);
}
//+---------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------+
//| Инициализация всех индикаторных буферов                                                                                                                                                           |
//+---------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------+
void BuffersInitializeAll()
{
   ArrayInitialize(g_bullBuffer, 0);     
   ArrayInitialize(g_bearBuffer, 0);     
   ArrayInitialize(g_bullPrevalenceBuffer, 0);     
   ArrayInitialize(g_bearPrevalenceBuffer, 0);
}
//+---------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------+
//| Определение индекса бара, с которого необходимо производить перерасчет                                                                                                                            |
//+---------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------+
int GetRecalcIndex(int& total, const int ratesTotal, const int prevCalculated)
{
   // Определение первого бара истории, на котором будут доступны адекватные значения индикатора
   total = ratesTotal - 1;                                                                         
                                                   
   // А может значения индикатора не нужно отображать на всей истории?
   if (i_indBarsCount > 0 && i_indBarsCount < total)
      total = MathMin(i_indBarsCount, total);                      
                                                   
   // Первое отображение индикатора или произошла подкачка данных, т. е. на предыдущем тике баров было не на один бар меньше, как при нормальном развитии истории, а на два или более баров меньше
   if (prevCalculated < ratesTotal - 1)                     
   {       
      BuffersInitializeAll();
      return (total);
   }
   
   // Нормальное развитие истории. Количество баров текущего тика отличается от количества баров предыдущего тика не больше, чем на один бар
   return (MathMin(ratesTotal - prevCalculated, total));                            
}
//+---------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------+
//| Больше ли первое число, чем второе?                                                                                                                                                               |
//+---------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------+
bool IsFirstMoreThanSecond(double first, double second)
{
   return (first - second > Point / 10);
}
//+---------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------+
//| Равны ли сравниваемые величины?                                                                                                                                                                   |
//+---------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------+
bool IsValuesEquals(double first, double second)
{
   return (MathAbs(first - second) < Point / 10);
}
//+---------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------+
//| Чтение одного тика из файла                                                                                                                                                                       |
//+---------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------+
bool IsReadTimeAndBidAskOfTick(int hTicksFile, TickStruct &tick)
{
   if (FileIsEnding(hTicksFile))
   {
      FileClose(hTicksFile);
      return false;
   }
   
   uint bytesCnt = FileReadStruct(hTicksFile, tick);
   if (bytesCnt == sizeof(TickStruct))
      return true;
   
   FileClose(hTicksFile);
   return false;
}
//+---------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------+
//| Обработка одного тика                                                                                                                                                                             |
//+---------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------+
void ProcessOneTick(int index, TickStruct &curTick, TickStruct &lastTick)
{
   // Обнаружен рост цены
   if (IsFirstMoreThanSecond(curTick.bid, lastTick.bid))
   {
      if (i_useTicksAtPrice == POINTS)
         g_bullBuffer[index] += MathRound((curTick.bid - lastTick.bid) / g_tickSize);
      else
         g_bullBuffer[index]++;
   }

   // Обнаружено падение цены
   if (IsFirstMoreThanSecond(lastTick.bid, curTick.bid))
   {
      if (i_useTicksAtPrice == POINTS)
         g_bearBuffer[index] -= MathRound((lastTick.bid - curTick.bid) / g_tickSize);
      else
         g_bearBuffer[index]--;
   }
      
   lastTick = curTick;
    
   // Тиков роста цены больше, чем тиков падения цены    
   if (g_bullBuffer[index] >= MathAbs(g_bearBuffer[index]))
   {
      g_bearPrevalenceBuffer[index] = 0;
      g_bullPrevalenceBuffer[index] = g_bullBuffer[index] + g_bearBuffer[index];
      return;
   }

   // Тиков падения цены больше, чем тиков роста цены    
   if (MathAbs(g_bearBuffer[index]) > g_bullBuffer[index])
   {
      g_bullPrevalenceBuffer[index] = 0;
      g_bearPrevalenceBuffer[index] = g_bearBuffer[index] + g_bullBuffer[index];
   }
}
//+---------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------+
//| Определение принадлежности тика указанному бару                                                                                                                                                   |
//+---------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------+
bool IsTickBelongToBar(const TickStruct &tick, const int barIndex)
{
   if (barIndex > 0)
      return (tick.time >= Time[barIndex] && tick.time < Time[barIndex - 1]);
      
   return true;
}
//+---------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------+
//| Отображение данных по историческим барам, начиная с указанного                                                                                                                                    |
//+---------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------+
void ProcessOldCandles(int limit, TickStruct &lastTick)
{
   // Открытие файла тиковой истории
   int hTicksFile = FileOpen(Symbol() + ".tks", FILE_BIN | FILE_READ | FILE_SHARE_READ | FILE_SHARE_WRITE);
   if (hTicksFile < 1)
      return;
      
   // Поиск первого тика, принадлежащего бару limit или любому более позднему бару
   TickStruct tick = {0, 0, 0};
   while (!IsStopped())
   {
      if (!IsReadTimeAndBidAskOfTick(hTicksFile, tick))
         return;
         
      if (tick.time >= Time[limit])
         break;
   }
   lastTick = tick;
   int barIndex = iBarShift(NULL, 0, tick.time);
   
   // Отображение данных
   while (barIndex >= 0)
   {
      if (!IsReadTimeAndBidAskOfTick(hTicksFile, tick))
         return;
      
      if (!IsTickBelongToBar(tick, barIndex))
         barIndex = iBarShift(NULL, 0, tick.time);
         
      ProcessOneTick(barIndex, tick, lastTick);
   }
   
   FileClose(hTicksFile);
}
//+---------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------+
//| Добавление в окно отображения индикатора данных, накопленных ранее во время работы индикатора                                                                                                     |
//+---------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------+
void ProcessBufferTicks(int limit, TickStruct &lastTick)
{
   int total = ArraySize(g_ticks), i = 0;
   datetime limitTime = Time[limit];
   
   if (lastTick.time > 0)
      limitTime = lastTick.time + 1;

   // Поиск данных в буфере, время которых больше или равно времени открытия бара limit, или больше, чем данные о последнем прочитанном из файла тике
   while (i < total && g_ticks[i].time < limitTime)
      i++;
      
   if (i >= total)                                                                              // Нет данных для отображения
      return;
      
   // Копирование данных в буфера индикатора
   while (i < total)
   {
      int barIndex = iBarShift(NULL, 0, g_ticks[i].time);
      ProcessOneTick(barIndex, g_ticks[i], lastTick);
      i++;  
   }
}
//+---------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------+
//| Запись данных о тике в массив g_ticks                                                                                                                                                             |
//+---------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------+
bool IsUpdateTicksArray(TickStruct &tick)
{
   int total = ArraySize(g_ticks);
   if (ArrayResize(g_ticks, total + 1, 100) < 0)
   {
      Alert(WindowExpertName(), ": индикатору не хватает памяти для сохранения данных об очередном тике.");
      return false;
   }
   
   g_ticks[total] = tick;
   return true;
}
//+---------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------+
//| Добавление тика в масив новых тиков                                                                                                                                                               |
//+---------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------+
bool AddNewTick(TickStruct &tick)
{
   tick.time = TimeCurrent();
   tick.bid = Bid;
   tick.ask = Ask;
   
   // Добавление одного тика в массив хранения тиков   
   if (IsUpdateTicksArray(tick))
      return true;

   g_activate = false;
   return false;
}
//+---------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------+
//| Отображение данных индикатора                                                                                                                                                                     |
//+---------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------+
void ShowIndicatorData(int limit, int total)
{
   static TickStruct lastTick = {0, 0, 0};

   if (limit > 0)
   {
      if (limit > 1)
      {
         lastTick.time = 0;
         lastTick.bid = 0;
         lastTick.ask = 0;
      }
      ProcessOldCandles(limit, lastTick);
      ProcessBufferTicks(limit, lastTick);
   }
         
   TickStruct tick = {0, 0, 0};
   if (!AddNewTick(tick))
      return;
      
   ProcessOneTick(0, tick, lastTick);
}
//+---------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------+
//| Custom indicator iteration function                                                                                                                                                               |
//+---------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------+
int OnCalculate(const int rates_total,
                const int prev_calculated,
                const datetime& time[],
                const double& open[],
                const double& high[],
                const double& low[],
                const double& close[],
                const long& tick_volume[],
                const long& volume[],
                const int& spread[])
{
   if (!g_activate)                                                                                // Если индикатор не прошел инициализацию, то работать он не должен
      return rates_total;                                 
                                                   
   int total;   
   int limit = GetRecalcIndex(total, rates_total, prev_calculated);                                // С какого бара начинать обновление?

   ShowIndicatorData(limit, total);                                                                // Отображение данных индикатора
   
   return(rates_total);
}
