//+------------------------------------------------------------------+
//|                                              Triangle_H1_v46.mq4 |
//|      ВНИМАНИЕ!                                                   |
//|      экспериментальный Советник "Треугольник Чувашова"           |
//|      в реальных торгах без доработки не применять!               |
//|                                                  2011,autor,Gkov |
//|                                                     genkov@bk.ru |
//| некоторые рекомендации по доработке и усовершенствованию можно   |
//| посмотреть на странице сайта http://Forexmql.narod.ru/news.htm   |
//+------------------------------------------------------------------+
#property link      "http://Forexmql.narod.ru/index.htm" 
#property link      "http://forexparter.ucoz.ru/"
#property link      "http://ForexkovTrade.com"
#property link      "http://Animatyc.narod.ru" 
#property link      "http://Fxkom.narod.ru"

#property link      "genkov@bk.ru  kovgd@ya.ru"
//+------------------------------------------------------------------+
extern double SL_B=200;             
extern double TP_B=200;      
extern double SL_S=200; 
extern double TP_S=200;  
extern double Lots=1.0; 
double TrailingStop=40; 
int Magic;                  // номер надо ставить в блоке открытия позиций
extern int SlbH,SlbS;       // корректирующий SL_B   ( 0)
extern int SlsH,SlsS;       // корректирующий SL_S   (37)
extern int N=30;            // кол-во обсчитываемых баров 
extern int M= 3;            // начальный бар с которого начинаем поиск фракталов в цикле.
int    i,k,g,g1;            // номера баров в циклах.
int    Tfnb,Tfns;           // счетчик найденных фракталов b - верзних, s - нижних.
int    Tf1b,Tf2b,Tf1s,Tf2s; // номера фракталов для построения РЛК
int    Tf3s,Tf3b;           // номера фракталов для построения каналов
double TF1B,TF2B,TF1S,TF2S; // цены фракталов - реперные точки построения основной рабочей линии 
double TF3B,TF3S;           // цены фракталов - реперные точки построения каналов
datetime timf1b,timf2b,     // время верхних фракталов
         timf1s,timf2s;     // время нижних фракталов
double RatePriceH,RatePriceS; // скорость изменения цены
double PricB[60],PricS[60]; // цены проекций верхней и нижней рабочих линий треугольника
double RazmerS,RazmerH;     // размеры ширины каналов
double Starting_Price_H;    // начальное значения для расчета значений каждого бара проекций верхней РЛК
double Starting_Price_S;    // начальное значения для расчета значений каждого бара проекций нижней РЛК
int    cut_left;            // расчетный индекс точки пересечения рабочих линий слева (Апекс)
datetime time_Apex,         // предполагаемое реальное время пересечения РЛК
         time_starting,     // время начального расчета проекций РЛК 
         time_bar_zona,     // время зоны истинного прорыва
         T_period;          // кол-во секунд для построения вертикальных линий по периодам

bool   PatternTch=false;    // паттерн "Треугольник Чувашова"
bool   patternSell=false;   // значение true (истина) "1" или false (ложь) "0".
bool   patternBuy=false;    // значение true (истина) "1" или false (ложь) "0".
double VlFl_L;              // Min значение ближайшего нижнего фрактала на тренде вниз
double VlFl_H;              // Max значение ближайшего верхнего фрактала на тренде вверх
datetime tim1_L;            // Время ближайшего нижнего фрактала после нисходящего тренда ?
datetime timL1_H;           // Время ближайшего верхнего фрактала после восходящего тренда ?
double TP_Modific_B;        // Новое значение TakeProfit.
int    Md,MdL;              // счетчик кол-ва модификаций
double TP_Modific_S;        // Новое значение TakeProfit
bool   Open_chenel=false;   // запрет/разрешение на открытие позиций
double P_Tria;              // цена третьего угла треугольника

// --------------------------------------------------------------------+
  void Create_Tr_H() // отрисовка верхней линии канала по High фракталам
   {
   ObjectDelete("Tr_B1");
   ObjectCreate("Tr_B1",OBJ_TREND,0,timf2b,TF2B,timf1b,TF1B); 
   ObjectSet("Tr_B1",OBJPROP_COLOR,Lime);                        // цвет
   ObjectSet("Tr_B1",OBJPROP_WIDTH,1);                   // тонкая линия
   ObjectSet("Tr_B1",OBJPROP_STYLE,STYLE_SOLID);             // сплошная
   }
// --------------------------------------------------------------------+
  void Create_Tr_Hs() // отрисовка нижней линии канала по High фракталам
   {ObjectDelete("Tr_B1s");
   ObjectCreate("Tr_B1s",OBJ_TREND,0,timf2b,TF2B-RazmerH*Point,timf1b,
   TF1B-RazmerH*Point); 
   ObjectSet("Tr_B1s",OBJPROP_COLOR,Lime);                       // цвет
   ObjectSet("Tr_B1s",OBJPROP_WIDTH,1);                  // тонкая линия
   ObjectSet("Tr_B1s",OBJPROP_STYLE,STYLE_DOT);              // сплошная
   }
// --------------------------------------------------------------------+
  void Create_Tr_Hh()               // отрисовка профита для верхней РЛК 
   {ObjectDelete("Tr_B1h");
   ObjectCreate("Tr_B1h",OBJ_TREND,0,timf2b,TF2B+
   RazmerH*Point,timf1b,TF1B+RazmerH*Point);
   ObjectSet("Tr_B1h",OBJPROP_COLOR,Aqua);                       // цвет
   ObjectSet("Tr_B1h",OBJPROP_WIDTH,1);                  // тонкая линия
   ObjectSet("Tr_B1h",OBJPROP_STYLE,STYLE_DOT);            // пунктирная
   }
// --------------------------------------------------------------------+
  void Create_Tr_Hhh()        // отрисовка профита для верхней РЛК + 10%
   {ObjectDelete("Tr_B1hh");
   ObjectCreate("Tr_B1hh",OBJ_TREND,0,timf2b,TF2B+RazmerH*Point+
   RazmerH*Point*10/100,timf1b,TF1B+RazmerH*Point+RazmerH*Point*10/100); 
   ObjectSet("Tr_B1hh",OBJPROP_COLOR,Lime);                      // цвет
   ObjectSet("Tr_B1hh",OBJPROP_WIDTH,1);                 // тонкая линия
   ObjectSet("Tr_B1hh",OBJPROP_STYLE,STYLE_DOT);           // пунктирная
   }
// --------------------------------------------------------------------+
  void Create_Tr_Hhs()      // отрисовка профита для верхней РЛК - 10%
   {ObjectDelete("Tr_B1hs");
   ObjectCreate("Tr_B1hs",OBJ_TREND,0,timf2b,TF2B+RazmerH*Point-
   RazmerH*Point*10/100,timf1b,TF1B+RazmerH*Point-RazmerH*Point*10/100); 
   ObjectSet("Tr_B1hs",OBJPROP_COLOR,Lime);                      // цвет
   ObjectSet("Tr_B1hs",OBJPROP_WIDTH,1);                 // тонкая линия
   ObjectSet("Tr_B1hs",OBJPROP_STYLE,STYLE_DOT);           // пунктирная
   }
// --------------------------------------------------------------------+
  void Create_Tr_S()   // отрисовка нижней линии канала по Low фракталам 
   { 
   ObjectDelete("Tr_S1"); 
   ObjectCreate("Tr_S1",OBJ_TREND,0,timf2s,TF2S,timf1s,TF1S);
   ObjectSet("Tr_S1",OBJPROP_COLOR,Lime);                        // цвет 
   ObjectSet("Tr_S1",OBJPROP_WIDTH,1);                   // тонкая линия
   ObjectSet("Tr_S1",OBJPROP_STYLE,STYLE_SOLID);             // сплошная 
   }
// --------------------------------------------------------------------+
  void Create_Tr_Sh()  //отрисовка верхней линии канала по Low фракталам 
   { 
   ObjectDelete("Tr_S1h"); 
   ObjectCreate("Tr_S1h",OBJ_TREND,0,timf2s,TF2S+RazmerS*Point,
   timf1s,TF1S+RazmerS*Point);
   ObjectSet("Tr_S1h",OBJPROP_COLOR,Aqua);                       // цвет 
   ObjectSet("Tr_S1h",OBJPROP_WIDTH,1);                  // тонкая линия
   ObjectSet("Tr_S1h",OBJPROP_STYLE,STYLE_DOT);            // пунктирная
   }
// --------------------------------------------------------------------+
  void Create_Tr_Ss()                    // отрисовка профита нижней РЛК
   {  ObjectDelete("Tr_S1s");
   ObjectCreate("Tr_S1s",OBJ_TREND,0,timf2s,TF2S-RazmerS*Point,timf1s,
   TF1S-RazmerS*Point);
   ObjectSet("Tr_S1s",OBJPROP_COLOR,Aqua);                       // цвет
   ObjectSet("Tr_S1s",OBJPROP_WIDTH,1);                  // тонкая линия
   ObjectSet("Tr_S1s",OBJPROP_STYLE,STYLE_DOT);            // пунктирная 
   }
// --------------------------------------------------------------------+
  void Create_Tr_Ssh()           // отрисовка профита нижней РЛК (+ 10%)
   { ObjectDelete("Tr_S1sh"); 
   ObjectCreate("Tr_S1sh",OBJ_TREND,0,timf2s,TF2S-RazmerS*Point+
   RazmerS*Point*10/100,timf1s,TF1S-RazmerS*Point+RazmerS*Point*10/100);
   ObjectSet("Tr_S1sh",OBJPROP_COLOR,Lime);                      // цвет 
   ObjectSet("Tr_S1sh",OBJPROP_WIDTH,1);                 // тонкая линия
   ObjectSet("Tr_S1sh",OBJPROP_STYLE,STYLE_DOT);           // пунктирная 
   }
// --------------------------------------------------------------------+
  void Create_Tr_Sss()           // отрисовка профита нижней РЛК (- 10%)
   { ObjectDelete("Tr_S1ss"); 
   ObjectCreate("Tr_S1ss",OBJ_TREND,0,timf2s,TF2S-RazmerS*Point-
   RazmerS*Point*10/100,timf1s,TF1S-RazmerS*Point-RazmerS*Point*10/100);
   ObjectSet("Tr_S1ss",OBJPROP_COLOR,Lime);                      // цвет 
   ObjectSet("Tr_S1ss",OBJPROP_WIDTH,1);                 // тонкая линия
   ObjectSet("Tr_S1ss",OBJPROP_STYLE,STYLE_DOT);           // пунктирная 
   }
//+--------------------------------------------------------------------+
  void Del_Frb()  // Удаление верхних реперных точек (значков фракталов) 
   {
   ObjectDelete("Fr1b"); ObjectDelete("Fr2b");
   }
// --------------------------------------------------------------------+
  void Del_Frs()   // Удаление нижних реперных точек (значков фракталов) 
   {
   ObjectDelete("Fr1s"); ObjectDelete("Fr2s");
   }
//+--------------------------------------------------------------------+
  void Del_TrLin()                           // Удаление трендовых линий 
   {
   ObjectDelete("Tr_B1"); ObjectDelete("Tr_S1"); 
   }
//+--------------------------------------------------------------------+
  void CreateArrow_Frb()             // отрисовка верхних реперных точек
    {
    ObjectDelete("Fr1b");
    ObjectCreate("Fr1b",OBJ_ARROW, 0, timf1b, TF1B+0.0015);
    ObjectSet("Fr1b", OBJPROP_COLOR, Yellow);                     //цвет
    ObjectSet("Fr1b", OBJPROP_ARROWCODE,217);           //217-код значка
    ObjectDelete("Fr2b");
    ObjectCreate("Fr2b",OBJ_ARROW, 0, timf2b, TF2B+0.0015);
    ObjectSet("Fr2b", OBJPROP_COLOR, Yellow);                     //цвет
    ObjectSet("Fr2b", OBJPROP_ARROWCODE,217);           //217-код значка
    }
//+--------------------------------------------------------------------+
  void CreateArrow_Frs()              // отрисовка нижних реперных точек
    {
    ObjectDelete("Fr1s");
    ObjectCreate("Fr1s",OBJ_ARROW, 0, timf1s, TF1S-0.0005);
    ObjectSet("Fr1s", OBJPROP_COLOR, Yellow);                     //цвет
    ObjectSet("Fr1s", OBJPROP_ARROWCODE,218);           //218-код значка
    ObjectDelete("Fr2s");
    ObjectCreate("Fr2s",OBJ_ARROW, 0, timf2s, TF2S-0.0005);
    ObjectSet("Fr2s", OBJPROP_COLOR, Yellow);                     //цвет
    ObjectSet("Fr2s", OBJPROP_ARROWCODE,218);           //218-код значка
    }
// --------------------------------------------------------------------+
  void CreateLzona()  // время вертикальной линии зоны истинного прорыва
   {
   ObjectDelete("zona");          
   ObjectCreate("zona",OBJ_VLINE,0,time_bar_zona,1.3258);
   ObjectSet("zona",OBJPROP_COLOR,Red);                          // цвет
   ObjectSet("zona",OBJPROP_WIDTH,1);                    // тонкая линия
   ObjectSet("zona",OBJPROP_STYLE,STYLE_DASH);              // Штриховая
   } 
// --------------------------------------------------------------------+
  void CreateLbasis()     // вертикальная линия в основании треугольника
   {
   ObjectDelete("L1");
   ObjectCreate("L1",OBJ_VLINE,0,time_starting,1.4444);
   ObjectSet("L1",OBJPROP_COLOR,Aqua);                           // цвет
   ObjectSet("L1",OBJPROP_WIDTH,1);                      // тонкая линия
   ObjectSet("L1",OBJPROP_STYLE,STYLE_DASH);         // Штрих-пунктирная 
   } 
// --------------------------------------------------------------------+
  void CreateLApex()       // вертикальная линия в точке пересечения РЛК  
   {
   ObjectDelete("Ap");
   ObjectCreate("Ap",OBJ_VLINE,0,time_Apex,1.3258);
   ObjectSet("Ap",OBJPROP_COLOR,Aqua);                           // цвет
   ObjectSet("Ap",OBJPROP_WIDTH,1);                      // тонкая линия
   ObjectSet("Ap",OBJPROP_STYLE,STYLE_DASH);         // Штрих-пунктирная 
   } 
// --------------------------------------------------------------------+
// --------------------------------------------------------------------+
 void Op_Sell_Ch()
  { 
  if(!OrderSend(Symbol(),OP_SELL,Lots,Bid,2,Ask+SL_S*Point,
      Bid-TP_S*Point," ",Magic,0,Red)) 
      { Print("  Ошибка открытия ордера SELL  # ",GetLastError()); }
      return(0);
     }
// --------------------------------------------------------------------+
 void Op_Buy_Ch()
  {
  if(!OrderSend(Symbol(),OP_BUY,Lots,Ask,2,Bid-SL_B*Point,
      Ask+TP_B*Point," ",Magic,0,Blue))
      { Print("  Ошибка открытия ордера SELL  # ",GetLastError()); }
      return(0);
     }
//+--------------------------------------------------------------------+
// void Close_B_Ch()
//  {
//  if(!OrderClose(OrderTicket(),OrderLots(),Bid,2,Aqua))  
//      {Print(" Зак.орд.# ",OrderTicket()," Ошибка # ",GetLastError());}
//       return(0);
//     }
//+--------------------------------------------------------------------+
// void Close_S_Ch()
//  {
//  if(!OrderClose(OrderTicket(),OrderLots(),Ask,2,Aqua))  
//      {Print(" Зак.орд.# ",OrderTicket()," Ошибка # ",GetLastError());}
//      return(0);
//     }
//+--------------------------------------------------------------------+
  void CreateTriangleH()      // отрисовка Треугольника по верхней линии
   {
   ObjectDelete("TRH");  
   ObjectCreate("TRH",OBJ_TRIANGLE,0,timf2s,TF2S,timf2s,Starting_Price_H,
   timf2s+cut_left*T_period,P_Tria); 
   ObjectSet("TRH",OBJPROP_COLOR,Teal);                          // цвет 
   } 
//+--------------------------------------------------------------------+
  void CreateTriangleS()        // отрисовка Треугольник по нижней линии
   {
   ObjectDelete("TRS");  
   ObjectCreate("TRS",OBJ_TRIANGLE,0,timf2b,TF2B,timf2b,Starting_Price_S,
   timf2b+cut_left*T_period,P_Tria); 
   ObjectSet("TRS",OBJPROP_COLOR,Teal);                          // цвет 
   }
// ====================================================================+
//+--------------------------------------------------------------------+
   int start()
   {
    int spread=MarketInfo(Symbol(),MODE_SPREAD);
    int StopLevel=MarketInfo(Symbol(),MODE_STOPLEVEL);
    datetime Tm1=TimeCurrent();  // время на "0" баре
//+--------------------------------------------------------------------+
// - блок обнуления переменных  ---------------------------------------+
   TF1B=0; TF2B=0; TF1S=0; TF2S=0;      // цены                        +
   Tfnb=0; Tfns=0;                      // счетчики                    +
   timf1b=0;timf2b=0;timf1s=0;timf2s=0; // время                       +
   Tf1b=0;Tf2b=0;Tf1s=0;Tf2s=0;         // индексы                     +
   PatternTch=false;                    // паттерн                     +
   RatePriceH=0;RatePriceS=0;           // скорость изменения цены     +
   Open_chenel=false;                   // запрет/разрешение           +
   P_Tria=0;                        // цена третьего угла треугольника +
// -----------------------------------------блок  обнуления переменных-+
//+--------------------------------------------------------------------+
   if(Volume[0]>1) return;//начинаем торги при первом тике нового бара
    { // Vol-при первом тике
//+--------------------------------------------------------------------+
//  -блок значений для таймфреймов ------------------------------------+
    switch (Period())
	 {
	 case 60:   T_period=  3600; break;
	 case 240:  T_period= 14400; break;
    default:   Alert("У Вас эксперт не на том таймфрейме!"); 
    }
//   ----------------------------------- блок значений для таймфреймов-+
// ====================================================================+
// (блок поиска верхних и нижних фракталов) ---------------------------+
   for (i=M;i<=N;i++) // цикл нахождения реперных точек (фракталов)
    {//цикл b
   // поиск верхних фракталов -----------------------------------------+
   if(High[i]>High[i+1] && High[i]>High[i+2] && 
      High[i]>High[i-1] && High[i]>High[i-2])
     {// фрат_b
      Tfnb++;   // счетчик 
   // ----------------------------  
     if(Tfnb==1)     
	   {             // для 1-го фрактала: цена, номер, время.
	   TF1B=High[i]; Tf1b=i; timf1b=iTime(Symbol(),Period(),i); 
      }//-счетчик_1
   // ----------------------------
	  if(Tfnb==2)    
	   {//счетчик_2                       // цена, номер, время.
	    TF2B=High[i]; Tf2b=i; timf2b=iTime(Symbol(),Period(),i); break;
	   }//-счетчик_2
	// ----------------------------   
     }//-фрат_b
    }//-цикл b
// --------------------------------------------------------------------+
   for (i=M;i<=N;i++) // цикл нахождения реперных точек (фракталов)
    {//цикл s
   // поиск нижних фракталов ------------------------------------------+
   if(Low[i]<Low[i+1] && Low[i]<Low[i+2] && 
      Low[i]<Low[i-1] && Low[i]<Low[i-2])
     {// фрак_s
      Tfns++; 
     if(Tfns==1)     
	   {//счетчик_1                    // цена, номер, время.
	   TF1S=Low[i]; Tf1s=i; timf1s=iTime(Symbol(),Period(),i); 
	   }//-счетчик_1
	   if(Tfns==2)      
	    {//счетчик_2                    // цена, номер, время.
	    TF2S=Low[i]; Tf2s=i; timf2s=iTime(Symbol(),Period(),i); break;
	   }//-счетчик_2
     }//-фрак_s
    }//- цикл s 
// ---------------------------(блок поиска верхних и нижних фракталов)-+
//+жжжжжжжжжжжжжжжжжжжжжжжжжжжжжжжжжжжжжжжжжжжжжжжжжжжжжжжжжжжжжжжжжжжжжжжжжжж+
// ---------------------------------------------------------------------------+
// - (Блок условий схождения РЛК для формирования Треугольника) --------------+
   // условия схождения, необходимые для формирования треугольника:
   // 1. первые фракталы должны отстоять друг от друга более, чем на 20-30 pip
   // 2. первые фракталы одной РЛК должны быть меньше вторых другой РЛК
   // 3. все 4-е реперные точки отличны от "0" т.е. имеют реальные значения
   // 4. временные характеристики реперных точек должны отличаться от "0".
   // 5. первая верхняя точна ниже 2-ой верхней и 1-ая нижняя выше 2-ой
   // 6. разность между вторыми фракталами линий не должна превышать 150 pip
// ---------------------------------------------------------------------------+
   if((TF1B-TF1S)>25*Point && 
      Tf1b<=Tf2s && Tf1s<=Tf2b && 
      TF1B>0 && TF1S>0 && TF2B>0 && TF2S>0 && 
      timf1b!=0 && timf2b!=0 && timf1s!=0 && timf2s!=0 &&
      TF1B<TF2B && TF1S>TF2S && 
      (TF2B-TF2S)/Point<150)   
    {// условия образования тр-ка
 //===========================================================================+
 // Print(" общее кол-во= ",g2," в треугольниках ",g1); // результат: 8507; 814
//============================================================================+
// ---------------------------------------------------------------------------+
   // - (блок Расчёта скорость изменения цен)(верхней и нижней pip на один бар)
   if(TF1B!=TF2B) {RatePriceH=MathAbs((TF2B-TF1B)/(Tf2b-Tf1b));} // для верхней
   if(TF1S!=TF2S) {RatePriceS=MathAbs((TF1S-TF2S)/(Tf2s-Tf1s));}   // для нижне 
   // Print(" RatePriceS= ",RatePriceS); Print(" RatePriceH= ",RatePriceH);
// -------------------------------------(блок Расчёта скорость изменения цен)-+
//============================================================================+
/* На этот момент мы имеем: 4-е последних фрактала расположены в соответствии с
  условиями образования треугольника, но пока  не ясно, как далеко будет Апекс,
  и как будут располагаться зоны истинного прорыва и рискованного открытия поз.
  Так как расчет Апекса зависит от расположения второго фрактал из четырёх 
  последних по ходу их образования (на графике слева на право). Начальную 
  точку отсчета для более длинной РЛК надо определять, как точку пересечения
  вертикали проведенной через второй фрактал короткой РЛК с длинной РЛК.
  В этой связи, дальнейший алгоритм программы разветвляется на два направления
  расчета зон истинного прорыва: "длинная" верхняя и "длинная" нижняя РЛК. */
// ---------------------------------------------------------------------------+
// жжжжжжжжжжжжжжжжжжжжжжж 1. верхняя РЛК длиннее нижней  жжжжжжжжжжжжжжжжжжжж+ 
// - (блок поиска точки пересечения РЛК) -------------------------------------+
// Если верхняя РЛК длиннее нижней РЛК - находим точку пересечения  на 50 барах
   if(Tf2b>Tf2s && TF2B>TF1B && TF2S<TF1S)
    {// Верхняя РЛК длиннее
     // стартовой ценой для расчета значений на каждом баре верхней РЛК 
     Starting_Price_H=TF2B-RatePriceH*(Tf2b-Tf2s); 
     // стартовой ценой для расчета значений на каждом баре нижней РЛК 
     Starting_Price_S=TF2S;
     //время построения вертикальной линий в основании треугольника
     time_starting=timf2s; 
     // ------------------------------------
    for(int k=1;k<=50;k++)
    {//цикл 50b
     PricB[k]=Starting_Price_H-RatePriceH*k;          // минус скорость падения
     PricS[k]=Starting_Price_S+RatePriceS*k;          // плюс  скорость подъёма
     // если цены проекций  верхней и нижней линий  совпали,  или цена  верхней 
    if(PricB[k]<=PricS[k])   // стала меньше нижней значит есть пересечение РЛК 
     {//есть пересечение
     P_Tria=PricB[k-1];                      // цена третьего угла треугольника
     cut_left=k;  break;      // кол-во баров от основания до точки пересечения
     }//-есть пересечение
    }//-цикл 50b
// -------------------------------------- (блок поиска точки пересечений РЛК)-+
// ---------------------------------------------------------------------------+
// - (блок расчета временных отрезков для зоны истинного прорыва)-------------+
// Введём два дополнительных ограничения:
// 1. Апекс не должен отстоять от основания треугольника более, чем на 50 баров
// 2. Апекс не должен быть ближе, чем на 15 баров к основанию треугольника.
   if(cut_left<50 && cut_left>12)
    {//треугольник со всеми ограничениями
     time_Apex=timf2s+cut_left*T_period;             // время построения Апекса
     // разделим кол-во баров на три части, возьмем 2/3 и округлим их до челого
     // числа: MathRound(cut_left/3*2) -кол-во баров для зоны истинного прорыва
     time_bar_zona=time_starting+MathRound(cut_left/3*2)*T_period; //время зоны
     // выполнены условия построения паттерна, вычислена зона истинного прорыва  
     PatternTch=true;           // сформировался паттерн "Треугольник Чувашова"
     }//-треугольник со всеми ограничениями
// --------------(блок расчета временных отрезков для зоны истинного прорыва)-+
// ---------------------------------------------------------------------------+
// - (блок отрисовки треугольника после формирования паттерна) ---------------+
   if(PatternTch==true)
    {//есть паттерн
    Del_Frb(); Del_Frs();       // удаляем предыдущие верхние и нижние фракталы
    CreateArrow_Frb(); CreateArrow_Frs();  // наносим верхние и нижние фракталы
    Create_Tr_H(); Create_Tr_S();   // наносим верхние и нижние трендовые линии
    CreateLzona(); CreateLbasis(); CreateLApex(); // наносим вертикальные линии
    CreateTriangleH();               // отрисовка треугольника по верхней линии
    ObjectDelete("TRS");      // удаляем отрисовку треугольника по нижней линии
// -----------------(блок отрисовки треугольника после формирования паттерна)-+  
//+===========================================================================+
// - (блок расчета размера каналов по верхней и нижней РЛК) ------------------+ 
    // вычислим ширину канала (в pip) для Верхней РЛК 
    // индекс третьей точки для построения канала по Верхней РЛК
    Tf3s=iLowest(NULL,0,MODE_LOW,Tf2b,0);         
    TF3S=Low[Tf3s];  // цена третьей точки для построения канала по Верхней РЛК
    // ширина канала: - из цены Верхней РЛК на вертикале  индекса третьей точки 
    // вычитаем цену 3-ей реперной точки канала - получаем размер канала
    RazmerH=MathRound(((TF2B-(Tf2b-Tf3s)*RatePriceH)-TF3S)/Point); 
    // Print(" RazmerH ======= ",RazmerH);
    // -----------------------------------------------------------------------+
    // вычислим ширину канала (в pip) для Нижней РЛК 
    // индекс третьей точки для построения канала по Нижней РЛК
    Tf3b=iHighest(NULL,0,MODE_HIGH,Tf2s,0);        
    TF3B=High[Tf3b]; // цена третьей точки для канала по Нижней РЛК
    // ширина канала: - к цене Нижней РЛК на вертикале индекса третьей точки 
    // прибавляем цену 3-ей точки канала - получаем размер канала
    RazmerS=MathRound((TF3B-(TF2S+(Tf2s-Tf3b)*RatePriceS))/Point);
    // Print(" RazmerS ============ ",RazmerS);
// ------------------ (блок расчета размера каналов по верхней и нижней РЛК) -+
// жжжжжжжжжжжжжжжжжжжжжжжжжжжжжжжжжжжжжжжжжжжжжжжжжжжжжжжжжжжжжжжжжжжжжжжжжжж+
// - (блок открытия позиций при пробое линий РЛК) ----------------------------+
    if(((High[1]>TF2B-(Tf2b-1)*RatePriceH) || 
       (High[2]>TF2B-(Tf2b-2)*RatePriceH)) && 
       // цена пробовшего бара не должна отстоять от РЛК более, чем на половину
       // ширины пробитого канала можно, этот фильтр уточнить  при тестировании
       (Open[1]-TF2B-(Tf2b-1)*RatePriceH)<30*Point && 
       // время пробившего бара в зоне истинного пробоя
       iTime(Symbol(),Period(),1)<time_bar_zona &&     
       PatternTch==true && 
       OrdersTotal()<2)
     {
       Print(" =1B-метка === Buy Верхняя линия длиннее - пробой вверх" );
      // удаляем линии размеров профита канала по нижней РЛК 
      // дорисовываем размер канала и размер профита канала для верхней РЛК
      Create_Tr_Hh(); Create_Tr_Hhh(); Create_Tr_Hhs(); Create_Tr_Hs();
      // найдём разумную добавку к SlbH на тестере для конкретного условия 
      // (SlbH=43; для ближнего фрактала или SlbH=42; для дальнего фрактала)
      // стоплосс на уровне 1-го верхнего фрактала (плюс какая то добавка)
      SlbH=43; // для ближнего фрактала
      SL_B=MathRound((Bid-TF1S)/Point+SlbH); // SlbH определяется тестированием
      // или на уровне 2-го Фрактала (можно то же с добавкой или без неё)
      // SlbH=42; // для дальнего фрактала
      // SL_B=MathRound((Bid-TF2S)/Point+SlbH);
      // если Стоп Лосс близко к рынку:
      if(SL_B<StopLevel) SL_B=(Bid-(Bid-5*StopLevel*Point))/Point;  
      // профит на уровне - 100% ширины канала на вертикале 1-го бара
      // TP_B=MathRound((((TF2B-(Tf2b-1)*RatePriceH)+RazmerH*Point)-Bid)/Point);
      // для подстраховки можно уменьшить величину на 10% от 100% ширины канала
      TP_B=MathRound((((TF2B-(Tf2b-1)*RatePriceH)+RazmerH*Point)-Bid)/Point-
      RazmerH*10/100);
      Op_Buy_Ch();
    }
// --------------------------------------------
    if(((Low[1]<TF2S+(Tf2s-1)*RatePriceS) ||          // Min цена на 1-ом баре
       (Low[2]<TF2S+(Tf2s-2)*RatePriceS)) &&          // Min цена на 2-ом баре
       // цена пробовшего бара не должна уходить от РЛК более, чем на половину
       // ширины пробитого канала, этот фильтр можно уточнить при тестировании 
       (TF2S+(Tf2s-1)*RatePriceS)-Open[1]<30*Point && //
       iTime(Symbol(),Period(),1)<=time_bar_zona+3600 &&    // время пробившего бара   ###################
       PatternTch==true && 
       OrdersTotal()<2)  
      {
       Print(" =1S-метка Sell Верхняя линия длиннее - пробой вниз");
       // дорисовываем размер канала и размер профита канала для нижней РЛК
       Create_Tr_Ss(); Create_Tr_Ssh(); Create_Tr_Sss();Create_Tr_Sh(); 
       // найдём разумную добавку к SlsH на тестере для конкретного условия 
       // (SlsH=32; для ближнего фрактала или SlsH=20; для дальнего фрактала)
       // стоплосс на уровне 1-го верхнего фрактала плюс какая то добавка 
       SlsH=32; // для ближнего фрактала - определяется тестированием
       SL_S=MathRound((TF1B-Bid)/Point+SlsH); 
       // или на уровне 2-го Фрактала (можно то же с добавкой)
       // SL_S=MathRound((TF2B-Bid)/Point+SlsH);
       // профит на уровне 100% ширины канала на вертикале 1-го бара
       // TP_S=MathRound((Bid-(TF2S+(Tf2s-1)*RatePriceS-RazmerS*Point))/Point);
       // для подстраховки можно уменьшить эту величину на 10% ширины канала
       TP_S=MathRound((Bid-((TF2S+(Tf2s-1)*RatePriceS)-RazmerS*Point))/Point)-
       RazmerS*10/100;
       Op_Sell_Ch();
      }
// ----------------------------- (блок открытия позиций при пробое линий РЛК)-+
     }//-есть паттерн
    }//-Верхняя РЛК длиннее
// ===========================================================================+
// жжжжжжжжжжжжжжжжжжжжжжж 2. нижняя РЛК длиннее верхней  жжжжжжжжжжжжжжжжжжжж+
// - (блок поиска точки пересечения РЛК) -------------------------------------+
// Если нижняя РЛК длиннее верхней РЛК - находим точку пересечения  на 50 барах
   if(Tf2s>Tf2b && TF2B>TF1B && TF2S<TF1S) 
    {//Нижняя РЛК длиннее
     Starting_Price_H=TF2B;                    // стартовой ценой верхней линии
     Starting_Price_S=TF2S+RatePriceS*(Tf2s-Tf2b);    // стартовой ценой нижней
     time_starting=timf2b;              // время построения стартовой вертикали
// ------------------------------------------ 
    for(k=1;k<=50;k++)
     {//цикл 50s
      PricB[k]=Starting_Price_H-RatePriceH*k; 
      PricS[k]=Starting_Price_S+RatePriceS*k;
     if(PricB[k]<=PricS[k])  // стала меньше нижней значит есть пересечение РЛК
      {//есть пересечение
      P_Tria=PricB[k];                       // цена третьего угла треугольника
      cut_left=k; break;     // баров до точки пересечения рабочих линий канала
       }//-есть пересечение
      }//-цикл 50s
// -------------------------------------- (блок поиска точки пересечений РЛК)-+
// ---------------------------------------------------------------------------+
// - (блок расчета временных отрезков для зоны истинного прорыва)-------------+
     if(cut_left<50 && cut_left>12)
      {//если<50
      time_Apex=timf2b+cut_left*T_period;            // время построения Апекса
      // время зоны истинного прорыва
      time_bar_zona=time_starting+MathRound(cut_left/3*2)*T_period;//время зоны
      PatternTch=true;              // образован паттерн "Треугольник Чувашова"
     }//-если<50
// --------------(блок расчета временных отрезков для зоны истинного прорыва)-+
// ---------------------------------------------------------------------------+
// - (блок отрисовки треугольника после формирования паттерна) ---------------+
   if(PatternTch==true)
    {//есть паттерн
    Del_Frb(); Del_Frs();       // удаляем предыдущие верхние и нижние фракталы
    CreateArrow_Frb(); CreateArrow_Frs();  // наносим верхние и нижние фракталы
    Create_Tr_H(); Create_Tr_S();   // наносим верхние и нижние трендовые линии
    CreateLzona(); CreateLbasis(); CreateLApex(); // наносим вертикальные линии
    CreateTriangleS();               // отрисовка треугольника по нижней линии
    ObjectDelete("TRH");     // удаляем отрисовку треугольника по верхней линии
// -----------------(блок отрисовки треугольника после формирования паттерна)-+  
//+===========================================================================+
// - (блок расчета размера каналов по верхней и нижней РЛК) ------------------+ 
    // индекс третьей точки для построения канала по Верхней РЛК
    Tf3s=iLowest(NULL,0,MODE_LOW,Tf2b,0); 
    TF3S=Low[Tf3s]; // цена третьей точки для Нижней линии
    // из цены Верхней РЛК на вертикале индекса третьей точки 
    // (TF2B-(Tf2b-Tf3s)*RatePriceH) вычитаем цену 3-ей точки канала
    RazmerH=MathRound(((TF2B-(Tf2b-Tf3s)*RatePriceH)-TF3S)/Point); 
    // Print(" RazmerH= ",RazmerH);
    // -----------------------------------------------------------------------+
    // индекс третьей точки для построения канала по Нижней РЛК
    Tf3b=iHighest(NULL,0,MODE_HIGH,Tf2s,0); 
    TF3B=High[Tf3b];    // цена третьей реперной точки канала по Нижней РЛК
    // от цены третьей реперной точки канала отнимаем цену 
    // нижней РЛК на вертикале 3-ей реперной точки канала 
    RazmerS=MathRound((TF3B-(TF2S+(Tf2s-Tf3b)*RatePriceS))/Point); 
    // Print(" RazmerS= ",RazmerS);
// ------------------- (блок расчета размера каналов по верхней и нижней РЛК)-+
// жжжжжжжжжжжжжжжжжжжжжжжжжжжжжжжжжжжжжжжжжжжжжжжжжжжжжжжжжжжжжжжжжжжжжжжжжжж+
// - (блок открытия позиций при пробое линий РЛК) ----------------------------+
   if(((High[1]>TF2B-(Tf2b-1)*RatePriceH)  ||           
      (High[2]>TF2B-(Tf2b-2)*RatePriceH)) && 
      (Open[1]-TF2B-(Tf2s-1)*RatePriceS)<30*Point && 
      iTime(Symbol(),Period(),1)<time_bar_zona && 
      PatternTch==true && 
      OrdersTotal()<2)
     {
      // рисуем размер канала и размер профита канала
      Create_Tr_Hh(); Create_Tr_Hhh(); Create_Tr_Hhs(); Create_Tr_Hs(); 
      Print(" =2B= это метка для дальнейшего анализа!!");
      // стоплосс на уровне 1-го верхнего фрактала плюс какая то добавка 
      // тестированием или на уровне 2-го Фрактала (можно то же с добавкой)
      SlbS=6;
      SL_B=MathRound((Bid-TF1S)/Point+SlbS);
      // SlbS=1;
      // SL_B=MathRound((Bid-TF2S)/Point+SlbS);
      // профит на уровне 100% ширины канала на вертикале 1-го бара
      // TP_B=MathRound(((TF2B-(Tf2b-1)*RatePriceH+RazmerH*Point)-Bid)/Point);
      // для подстраховки можно уменьшить эту величину на 10% от ширины канала
      TP_B=MathRound((((TF2B-(Tf2b-1)*RatePriceH)+RazmerH*Point)-Bid)/Point-
      RazmerH*10/100);
      Op_Buy_Ch();
     }
// -------------------------------------------------- 
   if(((Low[1]<TF2S+(Tf2s-1)*RatePriceS) ||        // Min цена на 1-ом баре
      (Low[2]<TF2S+(Tf2s-2)*RatePriceS)) &&        // Min цена на 2-ом баре
      (TF2S+(Tf2s-1)*RatePriceS)-Open[1]<30*Point && 
      iTime(Symbol(),Period(),1)<time_bar_zona &&  // время пробившего бара
      PatternTch==true && 
      OrdersTotal()<2)  
     {
      Create_Tr_Ss(); Create_Tr_Ssh(); Create_Tr_Sss(); Create_Tr_Sh(); 
      Print(" =2S= это метка для дальнейшего анализа!!");
      // стоп-лосс на уровне 1-го верхнего фрактала плюс какая то добавка
      // тестированием или на уровне 2-го Фрактала (можно то же с добавкой)
      SlsS=5;
      SL_S=MathRound((TF1B-Bid)/Point+SlsS);
      // SlsS=3;
      // SL_S=MathRound((TF2B-Bid)/Point+SlsS);
      if(SL_S<StopLevel) SL_S=((Bid-10*StopLevel*Point)-Bid)/Point;
      // профит на уровне 100% ширины канала на вертикале 1-го бара
      // для подстраховки можно уменьшить эту величину на 10% от ширины канала
      // TP_S=MathRound((Bid-((TF2S+(Tf2s-1)*RatePriceS)-RazmerS*Point))/Point);
      TP_S=MathRound((Bid-((TF2S+(Tf2s-1)*RatePriceS)-RazmerS*Point))/Point)-
      RazmerS*10/100;
      Op_Sell_Ch();
     } 
// ---------------------------------
    }//-есть паттерн
   }//-Нижняя РЛК длиннее
// ---------------------------------------------------------------------------+
    }//-условия образования тр-ка
   }//Vol-при первом тике
// ===========================================================================+
// - (блок определения времени жизни паттерна) -------------------------------+
// если текущее время больше времени предела зоны открытия позиций - паттерн теряет силу
   if((TimeCurrent()-time_bar_zona)>=T_period)
    {
     PatternTch=false; // паттерн просрочен - ставим запрет на открытие позиций
    }
    // после того, когда текущее время станет больше времени Апекса
    if((TimeCurrent()-time_Apex)>=T_period) 
     {
      // удаляем с графика значки и линии паттерна 
      Del_Frs(); Del_Frb(); Del_TrLin();
      // удаляем линии размеров профита канала по верхней РЛК 
      ObjectDelete("Tr_B1h"); ObjectDelete("Tr_B1hh"); ObjectDelete("Tr_B1hs");ObjectDelete("Tr_B1s");
      // удаляем линии размеров профита канала по нижней РЛК 
      ObjectDelete("Tr_S1s"); ObjectDelete("Tr_S1sh"); ObjectDelete("Tr_S1ss");ObjectDelete("Tr_S1h");
      // удаляем вертикальные линии зоны истинного прорыва
      ObjectDelete("L1");ObjectDelete("zona");ObjectDelete("Ap");
      ObjectDelete("TRH"); ObjectDelete("TRS");
     }
// --------------------------------------------------------------------+
// --------------------------------------------------------------------+
//              Здесь можно вставить блок отслеживания позиций         +
// ---------------  по аналогии с блоком в Vilka_Ch.htm  --------------+
// --------------------------------------------------------------------+
   return(0);
  }
//+--------------------------------------------------------------------+